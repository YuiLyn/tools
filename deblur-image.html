<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>修復模糊圖片工具</title>
    <link rel="stylesheet" href="style.css">
    <script async src="https://docs.opencv.org/master/opencv.js"></script>
</head>
<body>
    <div class="container">
        <h1>修復模糊圖片工具</h1>
        <div class="input-group">
            <label for="imageUpload">上傳模糊圖片:</label>
            <input type="file" id="imageUpload" accept="image/*" onchange="loadImage()">
        </div>
        <div class="param-group">
            <label>去模糊強度: <span id="strengthValue">10</span></label>
            <input type="range" id="strengthSlider" min="1" max="20" value="10" oninput="updateParams()">
        </div>
        <div class="param-group">
            <label>PSF尺寸: <span id="psfSizeValue">5</span></label>
            <input type="range" id="psfSizeSlider" min="3" max="15" step="2" value="5" oninput="updateParams()">
        </div>
        <div id="downloadOptions" class="input-group">
            <label for="imageFormat">選擇輸出格式:</label>
            <select id="imageFormat">
                <option value="png">PNG</option>
                <option value="jpg">JPG</option>
            </select>
            <button onclick="downloadDeblurredImage()" id="downloadButton">下載修復後的圖片</button>
        </div>
        <div class="result" id="result">
            <div class="comparison-container">
                <div class="image-box">
                    <h3>原始圖片</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="image-box">
                    <h3>修復結果</h3>
                    <canvas id="processedCanvas"></canvas>
                </div>
            </div>
        </div>
        <p><a href="index.html">返回工具主頁</a></p>
    </div>

    <!-- 加載動畫 -->
    <div id="loading" class="loading-overlay">
        <div class="loading-spinner"></div>
        <p>正在處理中...</p>
    </div>

    <script>
        let originalImg = null;
        let processedImgSrc = '';
        let isProcessing = false;
        let currentParams = {
            strength: 10,
            psfSize: 5
        };

        // 初始化OpenCV
        function initializeOpenCV() {
            return new Promise((resolve, reject) => {
                if (cv.getBuildInformation) {
                    resolve();
                } else {
                    document.addEventListener('DOMContentLoaded', () => {
                        cv['onRuntimeInitialized'] = resolve;
                    });
                }
            });
        }

        async function loadImage() {
            if (isProcessing) return;
            
            const file = document.getElementById('imageUpload').files[0];
            if (!file) return;

            showLoading();
            
            try {
                // 讀取圖片
                const reader = new FileReader();
                reader.onload = async (e) => {
                    originalImg = new Image();
                    originalImg.src = e.target.result;
                    
                    originalImg.onload = async () => {
                        await initializeOpenCV();
                        processImage();
                    };
                };
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('圖片加載錯誤:', error);
                hideLoading();
            }
        }

        async function processImage() {
            try {
                isProcessing = true;
                
                // 創建OpenCV矩陣
                const src = cv.imread(originalImg);
                const dst = new cv.Mat();
                
                // 創建PSF（高斯模糊核）
                const psfSize = new cv.Size(currentParams.psfSize, currentParams.psfSize);
                const psf = new cv.Mat();
                cv.getGaussianKernel(currentParams.psfSize, currentParams.strength, cv.CV_32F).mul(
                    cv.getGaussianKernel(currentParams.psfSize, currentParams.strength, cv.CV_32F).t(),
                    1, psf
                );
                
                // 維納反卷積
                cv.deconvoWiener(src, dst, psf, currentParams.strength);
                
                // 顯示結果
                cv.imshow('processedCanvas', dst);
                
                // 保存結果
                processedImgSrc = document.getElementById('processedCanvas').toDataURL();
                
                // 清理內存
                src.delete();
                dst.delete();
                psf.delete();
                
                // 顯示下載選項
                document.getElementById('downloadOptions').style.display = 'block';
            } catch (error) {
                console.error('圖像處理錯誤:', error);
            } finally {
                isProcessing = false;
                hideLoading();
            }
        }

        function updateParams() {
            currentParams.strength = parseInt(document.getElementById('strengthSlider').value);
            currentParams.psfSize = parseInt(document.getElementById('psfSizeSlider').value);
            
            document.getElementById('strengthValue').textContent = currentParams.strength;
            document.getElementById('psfSizeValue').textContent = currentParams.psfSize;
            
            if (originalImg) {
                processImage();
            }
        }

        function downloadDeblurredImage() {
            const format = document.getElementById('imageFormat').value;
            const link = document.createElement('a');
            link.download = `deblurred_image.${format}`;
            link.href = processedImgSrc.replace('image/png', `image/${format}`);
            link.click();
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // 初始化Canvas尺寸
        function initCanvasSize() {
            const canvases = ['originalCanvas', 'processedCanvas'];
            canvases.forEach(id => {
                const canvas = document.getElementById(id);
                canvas.width = originalImg.width;
                canvas.height = originalImg.height;
            });
        }
    </script>
</body>
</html>
