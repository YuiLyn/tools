<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>固定强度去模糊对比工具</title>
    <link rel="stylesheet" href="style.css">
    <script async src="https://docs.opencv.org/master/opencv.js"></script>
</head>
<body>
    <div class="container">
        <h1>去模糊对比工具 (强度100%)</h1>
        <div class="input-group">
            <input type="file" id="imageUpload" accept="image/*" onchange="loadImage()">
        </div>
        
        <!-- 对比容器 -->
        <div class="comparison-wrapper" id="comparisonWrapper">
            <div class="before-container" id="beforeContainer">
                <canvas id="originalCanvas"></canvas>
            </div>
            <div class="after-container" id="afterContainer">
                <canvas id="processedCanvas"></canvas>
            </div>
            <div class="slider-handle" id="sliderHandle"></div>
        </div>
    </div>

    <script>
        let originalImg = null;
        let processedImg = null;
        let isDragging = false;
        const fixedStrength = 100; // 固定强度参数

        // OpenCV初始化
        function initializeOpenCV() {
            return new Promise((resolve) => {
                if (cv.getBuildInformation) resolve();
                else cv['onRuntimeInitialized'] = resolve;
            });
        }

        async function loadImage() {
            const file = document.getElementById('imageUpload').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                originalImg = new Image();
                originalImg.onload = async () => {
                    await initializeOpenCV();
                    processImage();
                    initComparison();
                };
                originalImg.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 固定强度去模糊处理
        async function processImage() {
            const src = cv.imread(originalImg);
            const dst = new cv.Mat();
            
            // 固定PSF尺寸与强度参数
            const psfSize = new cv.Size(15, 15);
            const psf = cv.Mat.ones(psfSize, cv.CV_32F);
            cv.normalize(psf, psf, 1, 0, cv.NORM_L1);
            
            // 维纳反卷积（固定强度）
            cv.deconvoWiener(src, dst, psf, fixedStrength/100);
            
            // 保存处理结果
            cv.imshow('processedCanvas', dst);
            processedImg = document.getElementById('processedCanvas');
            
            // 清理内存
            src.delete();
            dst.delete();
            psf.delete();
        }

        // 初始化对比滑块
        function initComparison() {
            const wrapper = document.getElementById('comparisonWrapper');
            const handle = document.getElementById('sliderHandle');
            
            // 设置画布尺寸
            ['originalCanvas', 'processedCanvas'].forEach(id => {
                const canvas = document.getElementById(id);
                canvas.width = originalImg.width;
                canvas.height = originalImg.height;
            });

            // 事件监听
            handle.addEventListener('mousedown', () => isDragging = true);
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const rect = wrapper.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width * 100;
                updateSliderPosition(Math.min(Math.max(percent, 0), 100));
            });
            document.addEventListener('mouseup', () => isDragging = false);
        }

        // 更新滑块位置
        function updateSliderPosition(percent) {
            const before = document.getElementById('beforeContainer');
            const handle = document.getElementById('sliderHandle');
            
            before.style.width = `${percent}%`;
            handle.style.left = `calc(${percent}% - 8px)`;
        }
    </script>
</body>
</html>
